import { NextRequest, NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';

// Create a simple in-memory cache for API results
const responseCache = new Map<string, {data: any, timestamp: number}>();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes in milliseconds

export async function GET(request: NextRequest) {
  try {
    // Get query parameters
    const searchParams = request.nextUrl.searchParams;
    const owner = searchParams.get('owner');
    const repo = searchParams.get('repo');
    const branch = searchParams.get('branch') || 'main';
    
    // Create a cache key
    const cacheKey = `${owner}/${repo}/${branch}`;
    
    // Check cache first
    const cachedResponse = responseCache.get(cacheKey);
    if (cachedResponse && (Date.now() - cachedResponse.timestamp < CACHE_TTL)) {
      console.log(`Using cached response for ${cacheKey}`);
      return NextResponse.json(cachedResponse.data);
    }
    
    console.log(`Accessing repomix JSON for ${owner}/${repo} (${branch})`);
    
    // Validate parameters
    if (!owner || !repo) {
      console.log('Missing required parameters');
      return NextResponse.json(
        { error: 'Missing required parameters: owner, repo' },
        { status: 400 }
      );
    }
    
    // Try multiple possible paths for the repository's repomix file
    const possiblePaths = [
      // Original path
      path.join(process.env.REPO_STORAGE_PATH || './storage', owner, repo, 'repomix-output.xml'),
      // With branch
      path.join(process.env.REPO_STORAGE_PATH || './storage', owner, repo, branch, 'repomix-output.xml'),
      // With 'repos' directory
      path.join(process.env.REPO_STORAGE_PATH || './storage/repos', owner, repo, 'repomix-output.xml'),
      // With 'repos' directory and branch
      path.join(process.env.REPO_STORAGE_PATH || './storage/repos', owner, repo, branch, 'repomix-output.xml'),
      // Main/code variations
      path.join(process.env.REPO_STORAGE_PATH || './storage', owner, repo, 'main', 'code', 'repomix-output.xml'),
      path.join(process.env.REPO_STORAGE_PATH || './storage', owner, repo, 'code', 'main', 'repomix-output.xml'),
      path.join(process.env.REPO_STORAGE_PATH || './storage/repos', owner, repo, 'main', 'code', 'repomix-output.xml'),
      path.join(process.env.REPO_STORAGE_PATH || './storage/repos', owner, repo, 'code', 'main', 'repomix-output.xml')
    ];
    
    let foundPath = null;
    
    // Try each path until we find one that exists
    for (const testPath of possiblePaths) {
      if (fs.existsSync(testPath)) {
        console.log(`Found repomix file at: ${testPath}`);
        foundPath = testPath;
        break;
      }
    }
    
    // If no valid path was found, return an error
    if (!foundPath) {
      console.log('No repomix file found in any of the expected locations');
      return NextResponse.json(
        { error: 'Repomix file not found in any of the expected locations' },
        { status: 404 }
      );
    }
    
    // Read the repomix file
    const fileContent = fs.readFileSync(foundPath, 'utf8');
    console.log(`Read ${fileContent.length} bytes from ${foundPath}`);
    
    try {
      // Extract summary from the content - no need for XML parsing
      // Since the file isn't valid XML, we'll extract content using string operations
      const lines = fileContent.split('\n');
      let overview = '';
      
      // Extract file overview from the beginning
      for (let i = 0; i < Math.min(15, lines.length); i++) {
        if (lines[i] && !lines[i].includes('<') && !lines[i].includes('>')) {
          overview += lines[i] + ' ';
        }
      }
      
      // Create a simplified summary response
      const summary = {
        overview: overview.trim() || 'Repository analysis report generated by Repomix',
        aiAnalysis: '',
        languages: extractLanguagesFromText(fileContent),
        features: extractFeaturesFromText(fileContent),
        architecture: [],
        file_count: countFilesFromText(fileContent),
        directory_count: 0,
        key_files: extractKeyFilesFromText(fileContent),
        statistics: {
          total_files: countFilesFromText(fileContent),
          total_directories: 0, 
          lines_of_code: 0,
          code_size: `${Math.round(fileContent.length / 1024)} KB`
        }
      };
      
      // Store in cache
      responseCache.set(cacheKey, {
        data: summary,
        timestamp: Date.now()
      });
      
      return NextResponse.json(summary);
      
    } catch (parseError) {
      console.error('Error processing repomix file:', parseError);
      return NextResponse.json(
        { error: 'Error processing repomix data' },
        { status: 500 }
      );
    }
    
  } catch (error) {
    console.error('Error fetching repomix summary:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// Helper functions to extract data from the text content
function extractLanguagesFromText(text: string): { name: string; percentage: number }[] {
  const languages = [];
  const commonLanguages = ['JavaScript', 'TypeScript', 'HTML', 'CSS', 'Python', 'Java', 'C#', 'Ruby'];
  
  for (const lang of commonLanguages) {
    if (text.includes(lang)) {
      languages.push({
        name: lang,
        percentage: 0 // We can't determine percentages from the text
      });
    }
  }
  
  return languages;
}

function extractFeaturesFromText(text: string): string[] {
  const features = [];
  
  // Search for common keywords that might indicate features
  const featureKeywords = ['dashboard', 'authentication', 'api', 'component', 'framework', 'testing', 'database'];
  
  for (const keyword of featureKeywords) {
    if (text.toLowerCase().includes(keyword)) {
      features.push(keyword.charAt(0).toUpperCase() + keyword.slice(1));
    }
  }
  
  return features;
}

function countFilesFromText(text: string): number {
  // Count occurrences of file paths
  const fileMatches = text.match(/\.(js|jsx|ts|tsx|html|css|json|md|yaml|yml)/g);
  return fileMatches ? fileMatches.length : 0;
}

function extractKeyFilesFromText(text: string): string[] {
  const keyFiles: string[] = [];
  const lines = text.split('\n');
  
  // Look for lines that might contain file paths
  for (const line of lines) {
    if (line.includes('/') && line.match(/\.(js|jsx|ts|tsx|html|css|json|md|yaml|yml)$/)) {
      const path = line.trim().split(' ').find(word => 
        word.includes('/') && word.match(/\.(js|jsx|ts|tsx|html|css|json|md|yaml|yml)$/)
      );
      
      if (path && !keyFiles.includes(path) && keyFiles.length < 10) {
        keyFiles.push(path);
      }
    }
  }
  
  return keyFiles;
} 