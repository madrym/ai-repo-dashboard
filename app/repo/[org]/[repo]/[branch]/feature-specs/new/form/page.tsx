"use client"

import { useState, useEffect, ChangeEvent } from "react"
import { useParams, useRouter, useSearchParams } from "next/navigation"
import Link from "next/link"
import { ArrowLeft, Check, ChevronsUpDown, Loader2 } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group"
import { Checkbox } from "@/components/ui/checkbox"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Slider } from "@/components/ui/slider"
import { toast } from "@/components/ui/use-toast"

// --- Types --- 
interface FormQuestion {
  id: string; // Generated from question text for keying
  blockName?: string;
  question: string;
  type: 'radio' | 'checkbox list' | 'text area' | 'dropdown' | 'slider' | 'text'; // Added 'text' as default
  options?: string[];
}

interface FormAnswers {
  [questionId: string]: string | string[] | number | undefined;
}

// Type for the object stored in localStorage
interface StoredIdeaData {
  idea: string;
  markdown: string;
}

// --- Helper Functions --- 

// Basic slugify for generating unique IDs from question text
function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/\s+/g, '-')        // Replace spaces with -
    .replace(/[^\w-]+/g, '')    // Remove all non-word chars
    .replace(/--+/g, '-')        // Replace multiple - with single -
    .replace(/^-+/, '')          // Trim - from start of text
    .replace(/-+$/, '');         // Trim - from end of text
}

// Parses the Markdown structure generated by FormArchitect-GPT
function parseFormMarkdown(markdown: string): FormQuestion[] {
  const questions: FormQuestion[] = [];
  const step1Markdown = markdown.split('## Step\u202f2 â€“ Tasks')[0]; 
  const blocks = step1Markdown.split('### ').slice(1); 

  blocks.forEach(blockContent => {
    // Filter out empty lines FIRST
    const lines = blockContent.trim().split('\n').filter(line => line.trim() !== '');
    
    if (lines.length < 3) {
       console.warn("Skipping block due to insufficient lines:", blockContent);
       return; // Skip if not enough lines for name, question, type
    }
    
    const blockName = lines[0].trim();
    // Adjusted to check lines[1] and lines[2] which should now reliably hold question/type
    const questionMatch = lines[1]?.match(/^\*(.*)\*$/);
    const typeMatch = lines[2]?.match(/^\_\(input-type: (.*)\)_$/);

    if (questionMatch && typeMatch) {
      const question = questionMatch[1].trim();
      const type = typeMatch[1].trim() as FormQuestion['type'];
      const id = slugify(question);
      
      let options: string[] | undefined = undefined;
      if (type === 'radio' || type === 'checkbox list' || type === 'dropdown') {
        // Extract options from lines AFTER the type line (index 2)
        options = lines.slice(3)
                       .map(line => line.trim().replace(/^[-*]\s+/, ''))
                       .filter(line => line.length > 0 && !line.startsWith('---'));
      }

      questions.push({ id, blockName, question, type, options });
    } else {
      console.warn("Could not parse block structure (name/question/type):", blockName, lines.slice(0, 3));
    }
  });

  return questions;
}

// --- Component --- 
export default function GeneratedFormPage() {
  const router = useRouter()
  const params = useParams()
  const searchParams = useSearchParams()
  const org = params.org as string
  const repo = params.repo as string
  const branch = params.branch as string

  const [isLoading, setIsLoading] = useState(true)
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [featureIdea, setFeatureIdea] = useState<string | null>(null)
  const [formQuestions, setFormQuestions] = useState<FormQuestion[]>([])
  const [answers, setAnswers] = useState<FormAnswers>({})

  const ideaId = searchParams.get('ideaId')

  useEffect(() => {
    if (!ideaId) {
      toast({ title: "Error", description: "Missing idea identifier.", variant: "destructive" })
      router.back()
      return
    }

    setIsLoading(true);
    try {
      // --- Retrieve stored data from localStorage --- 
      const storedDataString = localStorage.getItem(ideaId!);
      if (!storedDataString) {
        throw new Error("Could not retrieve feature data from storage.");
      }
      
      // --- DEBUG LOG: Log the raw string --- 
      console.log("--- Raw Markdown String from localStorage ---");
      console.log(storedDataString);
      console.log("-------------------------------------------");
      // --- END DEBUG LOG --- 

      const storedData: StoredIdeaData = JSON.parse(storedDataString);
      if (!storedData.idea || !storedData.markdown) {
         throw new Error("Invalid data found in storage (missing idea or markdown).");
      }
      
      setFeatureIdea(storedData.idea);

      // --- DEBUG LOG: Log the markdown to be parsed --- 
      console.log("--- Markdown Content Being Parsed ---");
      console.log(storedData.markdown);
      console.log("-------------------------------------");
      // --- END DEBUG LOG ---

      // --- Parse the retrieved Markdown --- 
      const parsedQuestions = parseFormMarkdown(storedData.markdown);
      if (parsedQuestions.length === 0) {
        // Throw the specific error here
        throw new Error("Failed to parse form structure from stored markdown."); 
      }
      setFormQuestions(parsedQuestions);

      // --- Initialize answers state --- 
      const initialAnswers: FormAnswers = {};
      parsedQuestions.forEach(q => {
        initialAnswers[q.id] = q.type === 'checkbox list' ? [] : q.type === 'slider' ? (parseInt(q.options?.[0] || '1', 10)) : ''; // Default text/others to empty string
      });
      setAnswers(initialAnswers);

    } catch (error: any) {
      console.error("Error loading form page:", error);
      toast({ title: "Error", description: error.message || "Could not load the requirements form.", variant: "destructive" });
      setFormQuestions([]); 
    } finally {
      setIsLoading(false);
    }

  }, [ideaId, router]);

  // --- Event Handlers --- 
  const handleAnswerChange = (questionId: string, value: string | string[] | number | undefined) => {
    // --- DEBUGGING LOGS --- 
    console.log(`handleAnswerChange triggered for questionId: ${questionId}`);
    console.log(`New value:`, value);
    console.log(`Answers BEFORE update:`, answers);
    // --- END DEBUGGING LOGS --- 

    setAnswers(prev => {
      const newState = { ...prev, [questionId]: value };
      // --- DEBUGGING LOG --- 
      console.log(`Answers AFTER update:`, newState);
      // --- END DEBUGGING LOG --- 
      return newState;
    });
    // TODO: Consider adding validation/formatting for the ID field on blur/change if desired
  };

  const handleCheckboxChange = (questionId: string, option: string, checked: boolean) => {
    setAnswers(prev => {
      const currentSelection = (prev[questionId] as string[] || []);
      if (checked) {
        return { ...prev, [questionId]: [...currentSelection, option] };
      } else {
        return { ...prev, [questionId]: currentSelection.filter(item => item !== option) };
      }
    });
  };

  const handleSubmit = async () => {
    setIsSubmitting(true);
    console.log("Submitting answers:", answers);
    console.log("Original Idea:", featureIdea);

    // Ensure featureIdea and ideaId are available
    if (!featureIdea || !ideaId) {
      toast({ title: "Error", description: "Missing feature idea context.", variant: "destructive" });
      setIsSubmitting(false);
      return;
    }

    try {
      // --- Call the backend API to generate spec files --- 
      const response = await fetch('/api/feature-specs/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ideaId, // Pass the ideaId for potential cleanup/linking
          originalIdea: featureIdea,
          answers,
          org,
          repo,
          branch
        }),
      });

      if (!response.ok) {
        let errorData = { error: 'Failed to generate specification files' };
        try {
           errorData = await response.json();
        } catch (jsonError) {
           const textError = await response.text();
           errorData.error = textError || `Request failed with status ${response.status}`;
        }
        throw new Error(errorData.error);
      }

      const result = await response.json();
      const newFeatureId = result.newFeatureId;

      if (!newFeatureId) {
         throw new Error("Generation API did not return a new feature ID.");
      }

      // --- Success --- 
      toast({
        title: "Specification Generated",
        description: `Successfully created feature spec ${newFeatureId}.`,
      });

      // Clean up localStorage for the completed idea
      localStorage.removeItem(ideaId);

      // Navigate to the new feature spec page using the ID from the response
      router.push(`/repo/${org}/${repo}/${branch}/feature-specs/${newFeatureId}`);

    } catch (error: any) {
      console.error("Error submitting form:", error);
      toast({ 
        title: "Generation Error", 
        description: error.message || "Failed to generate feature specification.", 
        variant: "destructive" 
      });
      setIsSubmitting(false); // Keep user on the form page on error
    } 
    // No need to set submitting to false on success due to navigation
  };

  // --- Rendering Logic --- 
  const renderQuestionInput = (q: FormQuestion) => {
    const value = answers[q.id];

    switch (q.type) {
      case 'radio':
        return (
          <RadioGroup 
            value={value as string}
            onValueChange={(val) => handleAnswerChange(q.id, val)}
            disabled={isSubmitting}
          >
            {(q.options || []).map(option => (
              <div key={option} className="flex items-center space-x-2">
                <RadioGroupItem value={option} id={`${q.id}-${slugify(option)}`} />
                <Label htmlFor={`${q.id}-${slugify(option)}`}>{option}</Label>
              </div>
            ))}
          </RadioGroup>
        );
      case 'checkbox list':
        return (
          <div className="space-y-2">
            {(q.options || []).map(option => (
              <div key={option} className="flex items-center space-x-2">
                <Checkbox 
                  id={`${q.id}-${slugify(option)}`}
                  checked={(value as string[] || []).includes(option)}
                  onCheckedChange={(checked) => handleCheckboxChange(q.id, option, !!checked)}
                  disabled={isSubmitting}
                 />
                <Label htmlFor={`${q.id}-${slugify(option)}`}>{option}</Label>
              </div>
            ))}
          </div>
        );
      case 'dropdown':
        return (
          <Select 
            value={value as string}
            onValueChange={(val) => handleAnswerChange(q.id, val)}
            disabled={isSubmitting}
          >
            <SelectTrigger className="w-[280px]">
              <SelectValue placeholder={`Select ${q.blockName || 'option'}...`} />
            </SelectTrigger>
            <SelectContent>
              {(q.options || []).map(option => (
                <SelectItem key={option} value={option}>{option}</SelectItem>
              ))}
            </SelectContent>
          </Select>
        );
      case 'text area':
        return (
          <Textarea 
            id={q.id}
            value={value as string || ''}
            onChange={(e: ChangeEvent<HTMLTextAreaElement>) => handleAnswerChange(q.id, e.target.value)}
            placeholder={`Enter details for ${q.question}...`}
            rows={4}
            disabled={isSubmitting}
          />
        );
      case 'slider':
         // Assuming options provide min and max, or default
        const min = parseInt(q.options?.[0] || '1', 10);
        const max = parseInt(q.options?.[1] || '10', 10);
        return (
           <div className="flex items-center gap-4">
            <Slider 
                id={q.id}
                value={value !== undefined ? [Number(value)] : [min]} 
                onValueChange={(val) => handleAnswerChange(q.id, val[0])}
                min={min}
                max={max}
                step={1}
                disabled={isSubmitting}
                className="w-[80%]"
            />
            <span className="text-sm font-medium w-[20%] text-right">{value ?? min}</span>
           </div>
        );
      case 'text': // Fallback for simple text input
      default:
        return (
          <Input 
            id={q.id}
            type="text"
            value={value as string || ''}
            onChange={(e: ChangeEvent<HTMLInputElement>) => handleAnswerChange(q.id, e.target.value)}
            placeholder={`Enter value for ${q.question}...`}
            disabled={isSubmitting}
          />
        );
    }
  }

  const previousPageUrl = `/repo/${org}/${repo}/${branch}/feature-specs/new`;

  if (isLoading) {
    return (
      <div className="flex h-screen items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
        <p className="ml-2">Loading form...</p>
      </div>
    )
  }

  if (!formQuestions.length) {
     return (
      <div className="container mx-auto max-w-3xl py-8 text-center">
        <p className="mb-4">Could not load or parse the form questions.</p>
        <Link href={previousPageUrl}>
           <Button variant="outline">Go Back</Button>
        </Link>
      </div>
    )
  }

  return (
    <div className="container mx-auto max-w-3xl py-8">
       <Link href={previousPageUrl} className="inline-flex items-center text-sm text-muted-foreground hover:text-foreground mb-4">
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Feature Idea
        </Link>
      
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">Refine Feature Requirements</CardTitle>
          <CardDescription>
             Answer the questions below based on your feature idea:
             <blockquote className="mt-2 border-l-2 pl-4 italic text-sm">{featureIdea}</blockquote>
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {formQuestions.map((q) => (
             <div key={q.id} className="space-y-2 border-b pb-4 last:border-b-0 last:pb-0">
               <Label htmlFor={q.id} className="text-base font-medium flex items-center">
                 {/* Optional: Add icon based on blockName? */}
                 {q.question}
               </Label>
               {q.blockName && <p className="text-xs text-muted-foreground">Category: {q.blockName}</p>}
              {renderQuestionInput(q)}
            </div>
          ))}
        </CardContent>
        <CardFooter>
          <Button onClick={handleSubmit} disabled={isSubmitting} className="ml-auto">
            {isSubmitting ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Generating Specification...
              </>
            ) : (
              "Generate Specification"
            )}
          </Button>
        </CardFooter>
      </Card>
    </div>
  )
} 